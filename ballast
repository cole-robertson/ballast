#!/bin/bash
set -euo pipefail

VERSION="0.2.0"
DEFAULT_CONFIG="/etc/ballast.conf"

# State: "active" or "dropped"
STATE="active"

#
# Smart defaults
#
set_defaults() {
    # Default paths
    ballast_path="${ballast_path:-/var/lib/ballast/ballast.dat}"
    monitor_path="${monitor_path:-/}"
    monitor_interval="${monitor_interval:-30}"

    # Ballast-relative thresholds (multipliers)
    # drop_buffer=1.5 means drop when free space < 1.5x ballast size
    # recover_buffer=3.0 means recover when free space > 3.0x ballast size
    monitor_drop_buffer="${monitor_drop_buffer:-1.5}"
    monitor_recover_buffer="${monitor_recover_buffer:-3.0}"
    monitor_auto_recover="${monitor_auto_recover:-true}"

    # Calculate ballast size if not set
    if [[ -z "${ballast_size_gb:-}" ]]; then
        ballast_size_gb=$(calculate_ballast_size "$monitor_path")
    fi
}

# Calculate ballast size: 10GB default, cap at 20% of disk, minimum 1GB
calculate_ballast_size() {
    local path="$1"
    local disk_bytes=$(df -B1 "$path" | awk 'NR==2 {print $2}')
    local disk_gb=$((disk_bytes / 1024 / 1024 / 1024))

    local max_percent_gb=$((disk_gb * 20 / 100))  # 20% of disk
    local size=10  # default 10GB

    # Cap at 20% of disk
    if [[ $max_percent_gb -lt $size ]]; then
        size=$max_percent_gb
    fi

    # Minimum 1GB
    if [[ $size -lt 1 ]]; then
        size=1
    fi

    echo "$size"
}

#
# INI Parser - sets variables like section_key=value
#
parse_config() {
    local file="$1"
    local section=""

    [[ ! -f "$file" ]] && { echo "Config not found: $file" >&2; exit 1; }

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Trim whitespace
        line="${line#"${line%%[![:space:]]*}"}"
        line="${line%"${line##*[![:space:]]}"}"

        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[#\;] ]] && continue

        # Section header
        if [[ "$line" =~ ^\[([a-zA-Z0-9_]+)\]$ ]]; then
            section="${BASH_REMATCH[1]}_"
            continue
        fi

        # Key = value
        if [[ "$line" =~ ^([a-zA-Z0-9_]+)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            # Strip inline comments
            value="${value%%#*}"
            value="${value%%	#*}"
            # Trim trailing whitespace
            value="${value%"${value##*[![:space:]]}"}"
            # Remove surrounding quotes if present
            value="${value#\"}"
            value="${value%\"}"
            value="${value#\'}"
            value="${value%\'}"
            declare -g "${section}${key}=${value}"
        fi
    done < "$file"
}

#
# Disk usage helpers
#
get_disk_free_gb() {
    local free_bytes=$(df -B1 "$monitor_path" | awk 'NR==2 {print $4}')
    awk "BEGIN {printf \"%.1f\", $free_bytes / 1024 / 1024 / 1024}"
}

get_disk_free_bytes() {
    df -B1 "$monitor_path" | awk 'NR==2 {print $4}'
}

get_disk_usage_percent() {
    df "$monitor_path" | awk 'NR==2 {gsub(/%/,""); print $5}'
}

#
# Ballast file operations
#
create_ballast() {
    local size_bytes=$((ballast_size_gb * 1024 * 1024 * 1024))
    local dir=$(dirname "$ballast_path")

    mkdir -p "$dir"

    if command -v fallocate &>/dev/null; then
        fallocate -l "$size_bytes" "$ballast_path"
    else
        truncate -s "$size_bytes" "$ballast_path"
    fi
}

drop_ballast() {
    [[ -f "$ballast_path" ]] && rm -f "$ballast_path"
}

ballast_exists() {
    [[ -f "$ballast_path" ]]
}

get_ballast_size() {
    [[ -f "$ballast_path" ]] && stat -c%s "$ballast_path" || echo 0
}

#
# Threshold calculations
#
get_drop_threshold_gb() {
    awk "BEGIN {printf \"%.1f\", $ballast_size_gb * $monitor_drop_buffer}"
}

get_recover_threshold_gb() {
    awk "BEGIN {printf \"%.1f\", $ballast_size_gb * $monitor_recover_buffer}"
}

#
# Alert functions
#
send_alerts() {
    local event="$1"  # "dropped" or "recovered"
    local free_gb="$2"
    local message

    if [[ "$event" == "dropped" ]]; then
        message="ALERT: Disk on $(hostname) low (${free_gb}GB free). Ballast dropped to free ${ballast_size_gb}GB."
    else
        message="OK: Disk on $(hostname) recovered (${free_gb}GB free). Ballast recreated."
    fi

    # Slack
    if [[ "${slack_enabled:-false}" == "true" && -n "${slack_webhook:-}" ]]; then
        curl -sf -X POST -H 'Content-Type: application/json' \
            -d "{\"text\": \"$message\"}" \
            "$slack_webhook" >/dev/null 2>&1 || true
    fi

    # Discord
    if [[ "${discord_enabled:-false}" == "true" && -n "${discord_webhook:-}" ]]; then
        curl -sf -X POST -H 'Content-Type: application/json' \
            -d "{\"content\": \"$message\"}" \
            "$discord_webhook" >/dev/null 2>&1 || true
    fi

    # Generic webhook
    if [[ "${webhook_enabled:-false}" == "true" && -n "${webhook_url:-}" ]]; then
        local method="${webhook_method:-POST}"
        curl -sf -X "$method" -H 'Content-Type: application/json' \
            -d "{\"event\": \"$event\", \"free_gb\": $free_gb, \"hostname\": \"$(hostname)\", \"message\": \"$message\"}" \
            "$webhook_url" >/dev/null 2>&1 || true
    fi

    # Email via curl
    if [[ "${email_enabled:-false}" == "true" && -n "${email_smtp:-}" ]]; then
        local subject="[ballast] Disk $event on $(hostname)"
        printf "Subject: %s\nFrom: %s\nTo: %s\n\n%s" \
            "$subject" "${email_from:-}" "${email_to:-}" "$message" | \
        curl -sf --url "$email_smtp" \
            --mail-from "${email_from:-}" \
            --mail-rcpt "${email_to:-}" \
            --user "${email_user:-}:${email_pass:-}" \
            -T - >/dev/null 2>&1 || true
    fi
}

#
# State machine
#
check_and_act() {
    local free_gb=$(get_disk_free_gb)
    local drop_threshold=$(get_drop_threshold_gb)
    local recover_threshold=$(get_recover_threshold_gb)

    case "$STATE" in
        active)
            # Drop when free space < drop_buffer × ballast
            if awk "BEGIN {exit !($free_gb < $drop_threshold)}"; then
                echo "$(date -Iseconds) Free space ${free_gb}GB < ${drop_threshold}GB, dropping ballast"
                drop_ballast
                # Recalculate free space after drop
                free_gb=$(get_disk_free_gb)
                send_alerts "dropped" "$free_gb"
                STATE="dropped"
            fi
            ;;
        dropped)
            # Recover when free space > recover_buffer × ballast
            if [[ "${monitor_auto_recover}" == "true" ]] && awk "BEGIN {exit !($free_gb > $recover_threshold)}"; then
                echo "$(date -Iseconds) Free space ${free_gb}GB > ${recover_threshold}GB, recreating ballast"
                create_ballast
                # Recalculate free space after create
                free_gb=$(get_disk_free_gb)
                send_alerts "recovered" "$free_gb"
                STATE="active"
            fi
            ;;
    esac
}

#
# Commands
#
cmd_run() {
    local interval="${monitor_interval}"
    local drop_threshold=$(get_drop_threshold_gb)
    local recover_threshold=$(get_recover_threshold_gb)

    echo "Starting ballast daemon"
    echo "  Monitor: $monitor_path"
    echo "  Ballast: $ballast_path (${ballast_size_gb}GB)"
    echo "  Drop when: free < ${drop_threshold}GB (${monitor_drop_buffer}x ballast)"
    echo "  Recover when: free > ${recover_threshold}GB (${monitor_recover_buffer}x ballast)"
    echo "  Auto-recover: ${monitor_auto_recover}"
    echo "  Interval: ${interval}s"
    echo ""

    if ballast_exists; then
        STATE="active"
        echo "Ballast file exists, state: active"
    else
        STATE="dropped"
        echo "Ballast file missing, state: dropped"
    fi

    while true; do
        check_and_act
        sleep "$interval"
    done
}

cmd_init() {
    if ballast_exists; then
        echo "Ballast already exists: $ballast_path ($(numfmt --to=iec $(get_ballast_size)))"
        exit 0
    fi

    echo "Creating ballast file: $ballast_path (${ballast_size_gb}GB)"
    create_ballast
    echo "Done"
}

cmd_status() {
    local free_gb=$(get_disk_free_gb)
    local free_bytes=$(get_disk_free_bytes)
    local usage=$(get_disk_usage_percent)
    local drop_threshold=$(get_drop_threshold_gb)
    local recover_threshold=$(get_recover_threshold_gb)

    echo "Disk: $monitor_path"
    echo "  Free: $(numfmt --to=iec $free_bytes) (${free_gb}GB)"
    echo "  Usage: ${usage}%"
    echo ""
    echo "Ballast: $ballast_path"
    if ballast_exists; then
        echo "  Status: active"
        echo "  Size: $(numfmt --to=iec $(get_ballast_size))"
    else
        echo "  Status: dropped"
    fi
    echo ""
    echo "Thresholds (based on ${ballast_size_gb}GB ballast):"
    echo "  Drop when free < ${drop_threshold}GB (${monitor_drop_buffer}x)"
    echo "  Recover when free > ${recover_threshold}GB (${monitor_recover_buffer}x)"
    echo "  Auto-recover: ${monitor_auto_recover}"
}

cmd_drop() {
    if ! ballast_exists; then
        echo "Ballast not present"
        exit 0
    fi

    local size=$(get_ballast_size)
    drop_ballast
    echo "Dropped ballast file, freed $(numfmt --to=iec $size)"
}

cmd_setup() {
    echo "Ballast Setup"
    echo "============="
    echo ""

    # Monitor path first (needed for size calculation)
    echo "== Disk Monitor =="
    read -p "Mount point to monitor [/]: " inp_monitor
    inp_monitor="${inp_monitor:-/}"

    # Calculate recommended size based on disk
    local recommended_size=$(calculate_ballast_size "$inp_monitor")
    local disk_bytes=$(df -B1 "$inp_monitor" | awk 'NR==2 {print $2}')
    local disk_gb=$((disk_bytes / 1024 / 1024 / 1024))

    # Ballast settings
    echo ""
    echo "== Ballast File =="
    echo "Disk size: ${disk_gb}GB (recommended ballast: ${recommended_size}GB)"
    read -p "Ballast file path [/var/lib/ballast/ballast.dat]: " inp_path
    inp_path="${inp_path:-/var/lib/ballast/ballast.dat}"

    read -p "Ballast size in GB [$recommended_size]: " inp_size
    inp_size="${inp_size:-$recommended_size}"

    read -p "Check interval in seconds [30]: " inp_interval
    inp_interval="${inp_interval:-30}"

    echo ""
    echo "== Thresholds =="
    echo "Thresholds are multipliers of ballast size."
    echo "With ${inp_size}GB ballast:"
    local default_drop=$(awk "BEGIN {printf \"%.0f\", $inp_size * 1.5}")
    local default_recover=$(awk "BEGIN {printf \"%.0f\", $inp_size * 3.0}")
    echo "  - drop_buffer=1.5 means drop when free < ${default_drop}GB"
    echo "  - recover_buffer=3.0 means recover when free > ${default_recover}GB"
    echo ""

    read -p "Drop buffer multiplier [1.5]: " inp_drop_buffer
    inp_drop_buffer="${inp_drop_buffer:-1.5}"

    read -p "Recover buffer multiplier [3.0]: " inp_recover_buffer
    inp_recover_buffer="${inp_recover_buffer:-3.0}"

    read -p "Auto-recover when disk frees up? [Y/n]: " inp_auto_recover
    if [[ "${inp_auto_recover,,}" == "n" ]]; then
        inp_auto_recover="false"
    else
        inp_auto_recover="true"
    fi

    # Alerts
    echo ""
    echo "== Alerts =="

    # Slack
    read -p "Enable Slack alerts? [y/N]: " inp_slack
    slack_section="[slack]\nenabled = false"
    if [[ "${inp_slack,,}" == "y" ]]; then
        read -p "Slack webhook URL: " inp_slack_url
        slack_section="[slack]\nenabled = true\nwebhook = $inp_slack_url"
    fi

    # Discord
    read -p "Enable Discord alerts? [y/N]: " inp_discord
    discord_section="[discord]\nenabled = false"
    if [[ "${inp_discord,,}" == "y" ]]; then
        read -p "Discord webhook URL: " inp_discord_url
        discord_section="[discord]\nenabled = true\nwebhook = $inp_discord_url"
    fi

    # Email
    read -p "Enable Email alerts? [y/N]: " inp_email
    email_section="[email]\nenabled = false"
    if [[ "${inp_email,,}" == "y" ]]; then
        read -p "SMTP URL (e.g., smtps://smtp.gmail.com:465): " inp_smtp
        read -p "SMTP username: " inp_email_user
        read -s -p "SMTP password: " inp_email_pass
        echo ""
        read -p "From address: " inp_email_from
        read -p "To address: " inp_email_to
        email_section="[email]\nenabled = true\nsmtp = $inp_smtp\nuser = $inp_email_user\npass = $inp_email_pass\nfrom = $inp_email_from\nto = $inp_email_to"
    fi

    # Webhook
    read -p "Enable generic webhook alerts? [y/N]: " inp_webhook
    webhook_section="[webhook]\nenabled = false"
    if [[ "${inp_webhook,,}" == "y" ]]; then
        read -p "Webhook URL: " inp_webhook_url
        read -p "HTTP method [POST]: " inp_webhook_method
        inp_webhook_method="${inp_webhook_method:-POST}"
        webhook_section="[webhook]\nenabled = true\nurl = $inp_webhook_url\nmethod = $inp_webhook_method"
    fi

    # Calculate actual thresholds for display
    local actual_drop=$(awk "BEGIN {printf \"%.0f\", $inp_size * $inp_drop_buffer}")
    local actual_recover=$(awk "BEGIN {printf \"%.0f\", $inp_size * $inp_recover_buffer}")

    # Generate config
    config="# Ballast configuration
# Generated by: ballast setup

[ballast]
path = $inp_path
size_gb = $inp_size

[monitor]
path = $inp_monitor
interval = $inp_interval
# Thresholds are multipliers of ballast size
# drop_buffer=1.5 with ${inp_size}GB ballast = drop when free < ${actual_drop}GB
# recover_buffer=3.0 with ${inp_size}GB ballast = recover when free > ${actual_recover}GB
drop_buffer = $inp_drop_buffer
recover_buffer = $inp_recover_buffer
auto_recover = $inp_auto_recover

$(echo -e "$slack_section")

$(echo -e "$discord_section")

$(echo -e "$email_section")

$(echo -e "$webhook_section")
"

    echo ""
    echo "== Generated Config =="
    echo ""
    echo "$config"

    read -p "Write to $DEFAULT_CONFIG? [Y/n]: " inp_write
    if [[ "${inp_write,,}" != "n" ]]; then
        echo "$config" | sudo tee "$DEFAULT_CONFIG" > /dev/null
        echo ""
        echo "Config written to $DEFAULT_CONFIG"
        echo ""
        echo "Next steps:"
        echo "  1. ballast init       # Create ballast file"
        echo "  2. ballast run        # Start daemon (or use systemd)"
    fi
}

cmd_help() {
    cat <<EOF
ballast - Disk space emergency release system

Usage: ballast [options] <command>

Commands:
  run      Start the monitoring daemon
  init     Create the ballast file
  status   Show disk usage and ballast state
  drop     Manually drop the ballast file
  setup    Interactive configuration wizard
  version  Print version
  help     Print this help

Options:
  -c PATH  Config file (default: /etc/ballast.conf)

Defaults (no config needed):
  Ballast: 10GB (or 20% of disk if smaller)
  Drop: when free space < 1.5x ballast (15GB)
  Recover: when free space > 3.0x ballast (30GB)

EOF
}

#
# Main
#
main() {
    local config="$DEFAULT_CONFIG"
    local cmd=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c)
                config="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                cmd="$1"
                shift
                break
                ;;
        esac
    done

    # Commands that don't need config
    case "${cmd:-help}" in
        version)
            echo "ballast $VERSION"
            exit 0
            ;;
        help|--help|-h)
            cmd_help
            exit 0
            ;;
        setup)
            cmd_setup
            exit 0
            ;;
    esac

    # Load config if exists, otherwise use smart defaults
    if [[ -f "$config" ]]; then
        parse_config "$config"
    fi
    set_defaults

    case "$cmd" in
        run)    cmd_run ;;
        init)   cmd_init ;;
        status) cmd_status ;;
        drop)   cmd_drop ;;
        *)
            echo "Unknown command: $cmd" >&2
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
