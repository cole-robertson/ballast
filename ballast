#!/bin/bash
set -euo pipefail

VERSION="0.2.0"
DEFAULT_CONFIG="/etc/ballast.conf"

# State: "active" or "dropped"
STATE="active"

#
# Smart defaults
#
set_defaults() {
    # Default paths
    ballast_path="${ballast_path:-/var/lib/ballast/ballast.dat}"
    monitor_path="${monitor_path:-/}"
    monitor_interval="${monitor_interval:-30}"

    # Ballast-relative thresholds (multipliers)
    # drop_buffer=1.5 means drop when free space < 1.5x ballast size
    # recover_buffer=3.0 means recover when free space > 3.0x ballast size
    monitor_drop_buffer="${monitor_drop_buffer:-1.5}"
    monitor_recover_buffer="${monitor_recover_buffer:-3.0}"
    monitor_auto_recover="${monitor_auto_recover:-true}"

    # Calculate ballast size if not set
    if [[ -z "${ballast_size_gb:-}" ]]; then
        ballast_size_gb=$(calculate_ballast_size "$monitor_path")
    fi
}

# Calculate ballast size: 10GB default, cap at 20% of disk, minimum 1GB
calculate_ballast_size() {
    local path="$1"
    local disk_bytes=$(df -B1 "$path" | awk 'NR==2 {print $2}')
    local disk_gb=$((disk_bytes / 1024 / 1024 / 1024))

    local max_percent_gb=$((disk_gb * 20 / 100))  # 20% of disk
    local size=10  # default 10GB

    # Cap at 20% of disk
    if [[ $max_percent_gb -lt $size ]]; then
        size=$max_percent_gb
    fi

    # Minimum 1GB
    if [[ $size -lt 1 ]]; then
        size=1
    fi

    echo "$size"
}

#
# INI Parser - sets variables like section_key=value
#
parse_config() {
    local file="$1"
    local section=""

    [[ ! -f "$file" ]] && { echo "Config not found: $file" >&2; exit 1; }

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Trim whitespace
        line="${line#"${line%%[![:space:]]*}"}"
        line="${line%"${line##*[![:space:]]}"}"

        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[#\;] ]] && continue

        # Section header
        if [[ "$line" =~ ^\[([a-zA-Z0-9_]+)\]$ ]]; then
            section="${BASH_REMATCH[1]}_"
            continue
        fi

        # Key = value
        if [[ "$line" =~ ^([a-zA-Z0-9_]+)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            # Strip inline comments
            value="${value%%#*}"
            value="${value%%	#*}"
            # Trim trailing whitespace
            value="${value%"${value##*[![:space:]]}"}"
            # Remove surrounding quotes if present
            value="${value#\"}"
            value="${value%\"}"
            value="${value#\'}"
            value="${value%\'}"
            declare -g "${section}${key}=${value}"
        fi
    done < "$file"
}

#
# Disk usage helpers
#
get_disk_free_gb() {
    local free_bytes=$(df -B1 "$monitor_path" | awk 'NR==2 {print $4}')
    awk "BEGIN {printf \"%.1f\", $free_bytes / 1024 / 1024 / 1024}"
}

get_disk_free_bytes() {
    df -B1 "$monitor_path" | awk 'NR==2 {print $4}'
}

get_disk_usage_percent() {
    df "$monitor_path" | awk 'NR==2 {gsub(/%/,""); print $5}'
}

#
# Ballast file operations
#
create_ballast() {
    local size_bytes=$((ballast_size_gb * 1024 * 1024 * 1024))
    local dir=$(dirname "$ballast_path")

    mkdir -p "$dir"

    if command -v fallocate &>/dev/null; then
        fallocate -l "$size_bytes" "$ballast_path"
    else
        truncate -s "$size_bytes" "$ballast_path"
    fi
}

drop_ballast() {
    [[ -f "$ballast_path" ]] && rm -f "$ballast_path"
}

ballast_exists() {
    [[ -f "$ballast_path" ]]
}

get_ballast_size() {
    [[ -f "$ballast_path" ]] && stat -c%s "$ballast_path" || echo 0
}

#
# Threshold calculations
#
get_drop_threshold_gb() {
    awk "BEGIN {printf \"%.1f\", $ballast_size_gb * $monitor_drop_buffer}"
}

get_recover_threshold_gb() {
    awk "BEGIN {printf \"%.1f\", $ballast_size_gb * $monitor_recover_buffer}"
}

#
# Alert functions
#
post_json() {
    local url="$1" payload="$2"
    curl -sf -X POST -H 'Content-Type: application/json' -d "$payload" "$url" &>/dev/null || true
}

send_alerts() {
    local event="$1" free_gb="$2"
    local msg host=$(hostname)

    if [[ "$event" == "dropped" ]]; then
        msg="ALERT: Disk on $host low (${free_gb}GB free). Ballast dropped to free ${ballast_size_gb}GB."
    else
        msg="OK: Disk on $host recovered (${free_gb}GB free). Ballast recreated."
    fi

    [[ "${slack_enabled:-}" == "true" ]] && post_json "$slack_webhook" "{\"text\":\"$msg\"}"
    [[ "${discord_enabled:-}" == "true" ]] && post_json "$discord_webhook" "{\"content\":\"$msg\"}"
    [[ "${webhook_enabled:-}" == "true" ]] && post_json "$webhook_url" "{\"event\":\"$event\",\"free_gb\":$free_gb,\"hostname\":\"$host\",\"message\":\"$msg\"}"
}

#
# State machine
#
check_and_act() {
    local free_gb=$(get_disk_free_gb)
    local drop_threshold=$(get_drop_threshold_gb)
    local recover_threshold=$(get_recover_threshold_gb)

    case "$STATE" in
        active)
            # Drop when free space < drop_buffer × ballast
            if awk "BEGIN {exit !($free_gb < $drop_threshold)}"; then
                echo "$(date -Iseconds) Free space ${free_gb}GB < ${drop_threshold}GB, dropping ballast"
                drop_ballast
                # Recalculate free space after drop
                free_gb=$(get_disk_free_gb)
                send_alerts "dropped" "$free_gb"
                STATE="dropped"
            fi
            ;;
        dropped)
            # Recover when free space > recover_buffer × ballast
            if [[ "${monitor_auto_recover}" == "true" ]] && awk "BEGIN {exit !($free_gb > $recover_threshold)}"; then
                echo "$(date -Iseconds) Free space ${free_gb}GB > ${recover_threshold}GB, recreating ballast"
                create_ballast
                # Recalculate free space after create
                free_gb=$(get_disk_free_gb)
                send_alerts "recovered" "$free_gb"
                STATE="active"
            fi
            ;;
    esac
}

#
# Commands
#
cmd_run() {
    local interval="${monitor_interval}"
    local drop_threshold=$(get_drop_threshold_gb)
    local recover_threshold=$(get_recover_threshold_gb)

    echo "Starting ballast daemon"
    echo "  Monitor: $monitor_path"
    echo "  Ballast: $ballast_path (${ballast_size_gb}GB)"
    echo "  Drop when: free < ${drop_threshold}GB (${monitor_drop_buffer}x ballast)"
    echo "  Recover when: free > ${recover_threshold}GB (${monitor_recover_buffer}x ballast)"
    echo "  Auto-recover: ${monitor_auto_recover}"
    echo "  Interval: ${interval}s"
    echo ""

    if ballast_exists; then
        STATE="active"
        echo "Ballast file exists, state: active"
    else
        STATE="dropped"
        echo "Ballast file missing, state: dropped"
    fi

    while true; do
        check_and_act
        sleep "$interval"
    done
}

cmd_init() {
    if ballast_exists; then
        echo "Ballast already exists: $ballast_path ($(numfmt --to=iec $(get_ballast_size)))"
        exit 0
    fi

    echo "Creating ballast file: $ballast_path (${ballast_size_gb}GB)"
    create_ballast
    echo "Done"
}

cmd_status() {
    local free_gb=$(get_disk_free_gb)
    local free_bytes=$(get_disk_free_bytes)
    local usage=$(get_disk_usage_percent)
    local drop_threshold=$(get_drop_threshold_gb)
    local recover_threshold=$(get_recover_threshold_gb)

    echo "Disk: $monitor_path"
    echo "  Free: $(numfmt --to=iec $free_bytes) (${free_gb}GB)"
    echo "  Usage: ${usage}%"
    echo ""
    echo "Ballast: $ballast_path"
    if ballast_exists; then
        echo "  Status: active"
        echo "  Size: $(numfmt --to=iec $(get_ballast_size))"
    else
        echo "  Status: dropped"
    fi
    echo ""
    echo "Thresholds (based on ${ballast_size_gb}GB ballast):"
    echo "  Drop when free < ${drop_threshold}GB (${monitor_drop_buffer}x)"
    echo "  Recover when free > ${recover_threshold}GB (${monitor_recover_buffer}x)"
    echo "  Auto-recover: ${monitor_auto_recover}"
}

cmd_drop() {
    if ! ballast_exists; then
        echo "Ballast not present"
        exit 0
    fi

    local size=$(get_ballast_size)
    drop_ballast
    echo "Dropped ballast file, freed $(numfmt --to=iec $size)"
}

cmd_help() {
    cat <<EOF
ballast - Disk space emergency release system

Usage: ballast [options] <command>

Commands:
  status   Show disk and ballast state
  init     Create ballast file
  drop     Drop ballast (emergency)
  recover  Recreate ballast after drop
  run      Start daemon in foreground
  version  Print version

Options:
  -c PATH  Config file (default: /etc/ballast.conf)

Defaults (no config needed):
  Ballast: 10GB (or 20% of disk if smaller)
  Drop: when free space < 1.5x ballast (15GB)
  Recover: when free space > 3.0x ballast (30GB)

Configure alerts: sudo nano /etc/ballast.conf

EOF
}

#
# Main
#
main() {
    local config="$DEFAULT_CONFIG"
    local cmd=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c)
                config="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                cmd="$1"
                shift
                break
                ;;
        esac
    done

    # Commands that don't need config
    case "${cmd:-help}" in
        version)
            echo "ballast $VERSION"
            exit 0
            ;;
        help|--help|-h)
            cmd_help
            exit 0
            ;;
    esac

    # Load config if exists, otherwise use smart defaults
    if [[ -f "$config" ]]; then
        parse_config "$config"
    fi
    set_defaults

    case "$cmd" in
        run)             cmd_run ;;
        init|recover)    cmd_init ;;
        status)          cmd_status ;;
        drop)            cmd_drop ;;
        *)
            echo "Unknown command: $cmd" >&2
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
